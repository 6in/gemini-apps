<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSL UI TOOL v2.8 (Rich Guidelines)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React, ReactDOM, Babel -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- JS-YAML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <!-- Monaco Editor Loader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .font-mono {
            font-family: 'JetBrains+Mono', monospace;
        }

        /* アニメーション設定 */
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .slide-up {
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translateY(10px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Monaco Editor 用コンテナ */
        #monaco-container {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        // --- アイコンコンポーネント (SVG) ---
        const IconSettings = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" /></svg>;
        const IconTerminal = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 17 10 11 4 5" /><line x1="12" y1="19" x2="20" y2="19" /></svg>;
        const IconEye = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" /><circle cx="12" cy="12" r="3" /></svg>;
        const IconFileText = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14.5 2 14.5 7.5 20 7.5" /><line x1="8" y1="13" x2="16" y2="13" /><line x1="8" y1="17" x2="16" y2="17" /><line x1="8" y1="9" x2="10" y2="9" /></svg>;
        const IconBookOpen = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" /><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" /></svg>;
        const IconAlert = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><line x1="12" y1="8" x2="12" y2="12" /><line x1="12" y1="16" x2="12.01" y2="16" /></svg>;
        const IconCheck = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12" /></svg>;
        const IconCopy = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2" /><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" /></svg>;
        const IconRotate = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8" /><polyline points="21 3 21 8 16 8" /></svg>;
        const IconInfo = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><line x1="12" y1="16" x2="12" y2="12" /><line x1="12" y1="8" x2="12.01" y2="8" /></svg>;
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>;

        const GUIDELINES_TEXT = `# AI質問用DSL生成ガイドライン

このガイドラインは、AIがユーザーに対して構造化された質問を行い、効率的に情報を収集するための「質問用DSL（YAML形式）」を出力するための定義です。

### 1. 概要
ユーザーの要望が曖昧な場合や、多数のパラメータを確認する必要がある際、専用UIを生成するためのYAMLブロックを出力してください。

### 2. 出力のトリガー
* ユーザーの依頼内容に具体性が欠けている時。
* 複数の選択肢から選ばせたい、または詳細なヒアリングが必要な時。
* 「構造化対話（Structured Dialogue）」を用いて意思決定を加速させたい時。

### 3. DSL構文仕様（YAML形式）
* ルートノード \`questions\` の下にリスト形式で記述します。
* 出力は必ず Markdown のコードブロック (\`\`\`yaml) で囲んでください。

### 4. プロパティ定義
| プロパティ | 型 | 内容 |
| :--- | :--- | :--- |
| \`id\` | string | 質問の一意識別子（スネークケース推奨） |
| \`type\` | string | 質問タイプ (\`text\`, \`select\`, \`multi-select\`, \`boolean\`) |
| \`label\` | string | ユーザーに表示するメインの質問文 |
| \`description\` | string | (任意) 質問の下に表示する補足説明 |
| \`options\` | array | (\`select\`, \`multi-select\` 専用) 選択肢のリスト |
| \`placeholder\` | string | (\`text\` 専用) 入力欄に表示するヒントテキスト |
| \`required\` | boolean | (任意) 必須項目の場合は \`true\` |

### 5. 質問タイプの詳細
1. **text**: 自由記述。ユーザーに具体的なテキストを入力させます。
2. **select**: 単一選択。提示した選択肢から1つ選ばせます。
3. **multi-select**: 複数選択。当てはまるものを複数選ばせます。
4. **boolean**: 2択。「はい/いいえ」で答えられる質問に使用します。

### 6. 出力例
\`\`\`yaml
questions:
  - id: app_theme
    type: select
    label: アプリのテーマカラー
    description: UI全体の雰囲気を決定します
    options: ["モダン/ダーク", "クリーン/ライト", "カラフル"]
    required: true
  - id: feature_list
    type: multi-select
    label: 実装したい機能
    options: ["ログイン機能", "検索機能", "通知機能", "マイページ"]
  - id: contact_email
    type: text
    label: 通知用メールアドレス
    placeholder: "example@domain.com"
  - id: use_typescript
    type: boolean
    label: TypeScriptを採用しますか？
\`\`\`

### 7. 運用ルール
* 質問生成後には必ず「以下の内容をコピーして、専用ツールに貼り付けて回答してください」と案内してください。`;

        const DEFAULT_DSL = `questions:
  - id: user_name
    type: text
    label: お名前を教えてください
    placeholder: "例: 山田 太郎"
    required: true

  - id: target_audience
    type: select
    label: プロジェクトの対象読者
    options:
      - 初心者
      - 中級者
      - 上級者

  - id: technical_requirements
    type: multi-select
    label: 必要な技術スタック
    options:
      - React
      - TypeScript
      - Tailwind CSS
      - Node.js

  - id: confirm_policy
    type: boolean
    label: 利用規約に同意しますか？`;

        const App = () => {
            const [dslInput, setDslInput] = useState(DEFAULT_DSL);
            const [questions, setQuestions] = useState([]);
            const [answers, setAnswers] = useState({});
            const [error, setError] = useState(null);
            const [activeTab, setActiveTab] = useState('input');
            const [toast, setToast] = useState({ visible: false, message: '' });

            const editorRef = useRef(null);
            const containerRef = useRef(null);

            // トースト表示用共通関数
            const showToast = useCallback((message) => {
                setToast({ visible: true, message });
                setTimeout(() => setToast({ visible: false, message: '' }), 3000);
            }, []);

            // クリップボードコピー用共通関数
            const copyToClipboard = useCallback((text) => {
                const el = document.createElement('textarea');
                el.value = text;
                document.body.appendChild(el);
                el.select();
                try { document.execCommand('copy'); } catch (err) { }
                document.body.removeChild(el);
            }, []);

            // 各種ハンドラーの定義
            const handleInputChange = useCallback((id, value) => {
                setAnswers(prev => ({ ...prev, [id]: value }));
            }, []);

            const handleMultiSelectChange = useCallback((id, option, checked) => {
                setAnswers(prev => {
                    const current = prev[id] || [];
                    if (checked) return { ...prev, [id]: [...current, option] };
                    else return { ...prev, [id]: current.filter(item => item !== option) };
                });
            }, []);

            const handleCopyGuidelines = useCallback(() => {
                copyToClipboard(GUIDELINES_TEXT);
                showToast('ガイドラインをコピーしました');
            }, [copyToClipboard, showToast]);

            const resetForm = useCallback(() => {
                const initialAnswers = {};
                questions.forEach(q => {
                    if (q.type === 'multi-select') initialAnswers[q.id] = [];
                    else if (q.type === 'boolean') initialAnswers[q.id] = false;
                    else initialAnswers[q.id] = '';
                });
                setAnswers(initialAnswers);
                showToast('回答をリセットしました');
            }, [questions, showToast]);

            const handleClearDSL = useCallback(() => {
                if (editorRef.current) {
                    editorRef.current.setValue('');
                    setDslInput('');
                    showToast('エディタをクリアしました');
                }
            }, [showToast]);

            // DSLパース処理
            const parseDSL = useCallback((input) => {
                if (!window.jsyaml) return;
                try {
                    setError(null);
                    const trimmedInput = input.trim();
                    if (!trimmedInput) {
                        setQuestions([]);
                        return;
                    }
                    const data = window.jsyaml.load(trimmedInput);
                    const questionList = data?.questions;

                    if (!questionList || !Array.isArray(questionList)) {
                        throw new Error('DSLは questions: ルートノード配下のリスト形式である必要があります。');
                    }

                    setQuestions(questionList);
                    setAnswers(prev => {
                        const nextAnswers = {};
                        questionList.forEach(q => {
                            nextAnswers[q.id] = prev[q.id] !== undefined ? prev[q.id] : (q.type === 'multi-select' ? [] : (q.type === 'boolean' ? false : ''));
                        });
                        return nextAnswers;
                    });
                } catch (e) {
                    setError(e.message);
                }
            }, []);

            // Monaco Editor の初期化
            useEffect(() => {
                require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });
                require(['vs/editor/editor.main'], () => {
                    if (containerRef.current && !editorRef.current) {
                        editorRef.current = monaco.editor.create(containerRef.current, {
                            value: dslInput,
                            language: 'yaml',
                            theme: 'vs',
                            automaticLayout: true,
                            minimap: { enabled: false },
                            fontSize: 14,
                            scrollBeyondLastLine: false,
                            tabSize: 2,
                            lineNumbers: 'on',
                            renderLineHighlight: 'all',
                            scrollbar: { vertical: 'visible', horizontal: 'visible' }
                        });

                        editorRef.current.onDidChangeModelContent(() => {
                            setDslInput(editorRef.current.getValue());
                        });
                    }
                });

                return () => {
                    if (editorRef.current) {
                        editorRef.current.dispose();
                        editorRef.current = null;
                    }
                };
            }, []);

            // タブ切り替え時のレイアウト調整
            useEffect(() => {
                if (activeTab === 'input' && editorRef.current) {
                    setTimeout(() => editorRef.current.layout(), 50);
                }
            }, [activeTab]);

            // 入力変更時の自動パース
            useEffect(() => {
                parseDSL(dslInput);
            }, [dslInput, parseDSL]);

            // 回答のYAML生成
            const yamlOutput = useMemo(() => {
                if (!window.jsyaml || questions.length === 0) return '';
                try {
                    const filteredAnswers = questions.map(q => ({ id: q.id, value: answers[q.id] }));
                    return window.jsyaml.dump({ answers: filteredAnswers });
                } catch (e) { return 'YAML生成エラー'; }
            }, [answers, questions]);

            const handleFinishAndCopy = useCallback(() => {
                copyToClipboard(yamlOutput);
                showToast('回答を完了し、YAMLをコピーしました');
                setActiveTab('export');
            }, [yamlOutput, copyToClipboard, showToast]);

            return (
                <div className="min-h-screen p-4 md:px-10 flex flex-col items-center">
                    <header className="w-full max-w-5xl mb-6 flex flex-col md:flex-row md:items-end justify-between gap-4 flex-shrink-0">
                        <div>
                            <div className="flex items-center gap-3 mb-1">
                                <div className="p-2 bg-indigo-600 rounded-lg shadow-lg text-white"><IconSettings /></div>
                                <h1 className="text-2xl font-black tracking-tight text-slate-800">
                                    DSL UI TOOL <span className="text-indigo-600">v2.8</span>
                                </h1>
                            </div>
                            <p className="text-slate-500 text-sm italic">AI質問DSLエディタ & フォーム生成</p>
                        </div>
                        <button onClick={handleCopyGuidelines} className="flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all border bg-white border-slate-200 text-slate-600 hover:border-indigo-300 shadow-sm active:scale-95">
                            <IconBookOpen /> ガイドラインをコピー
                        </button>
                    </header>

                    <div className="w-full max-w-5xl bg-white rounded-2xl shadow-xl border border-slate-200 overflow-hidden flex flex-col h-[calc(100vh-180px)] relative">
                        <nav className="flex bg-slate-50 border-b border-slate-200 flex-shrink-0">
                            {[
                                { id: 'input', label: 'DSL編集', icon: <IconTerminal /> },
                                { id: 'preview', label: 'フォーム入力', icon: <IconEye /> },
                                { id: 'export', label: 'データ出力', icon: <IconFileText /> }
                            ].map(tab => (
                                <button key={tab.id} onClick={() => setActiveTab(tab.id)} className={`flex-1 flex items-center justify-center gap-2 py-4 text-sm font-bold transition-all relative ${activeTab === tab.id ? 'text-indigo-600 bg-white' : 'text-slate-400 hover:text-slate-600'}`}>
                                    {tab.icon} {tab.label}
                                    {activeTab === tab.id && <div className="absolute bottom-0 left-0 right-0 h-1 bg-indigo-600" />}
                                </button>
                            ))}
                        </nav>

                        <div className="flex-1 flex flex-col overflow-hidden">
                            {/* DSL編集タブ */}
                            <div className={`flex-1 flex flex-col ${activeTab === 'input' ? 'block' : 'hidden'}`}>
                                <div className="px-4 py-2 bg-slate-50 border-b border-slate-200 flex justify-between items-center">
                                    <span className="text-[10px] font-bold text-slate-400 uppercase tracking-widest">YAML Editor Mode</span>
                                    <button
                                        onClick={handleClearDSL}
                                        className="flex items-center gap-1.5 px-3 py-1 rounded-md text-[10px] font-bold bg-white border border-slate-200 text-slate-400 hover:text-red-500 hover:border-red-200 transition-all active:scale-95 shadow-sm uppercase"
                                    >
                                        <IconTrash /> エディタをクリア
                                    </button>
                                </div>
                                <div id="monaco-container" ref={containerRef} className="flex-1"></div>
                            </div>

                            {/* フォーム入力タブ */}
                            {activeTab === 'preview' && (
                                <div className="flex-1 p-6 md:p-10 overflow-y-auto fade-in bg-white">
                                    {error ? (
                                        <div className="bg-red-50 p-6 rounded-xl border border-red-200 text-red-600 text-sm">
                                            <div className="flex items-center gap-2 font-bold mb-1"><IconAlert /> パースエラー</div>
                                            {error}
                                        </div>
                                    ) : questions.length > 0 ? (
                                        <div className="max-w-2xl mx-auto space-y-8">
                                            <div className="flex items-center justify-between border-l-4 border-indigo-500 pl-4">
                                                <h2 className="text-xl font-bold text-slate-800">ヒアリングフォーム</h2>
                                                <button onClick={resetForm} className="text-slate-400 hover:text-red-500 flex items-center gap-1 text-[10px] font-bold uppercase tracking-tighter transition-colors">
                                                    <IconRotate /> 回答をクリア
                                                </button>
                                            </div>
                                            <div className="space-y-8 pb-10">
                                                {questions.map((q) => (
                                                    <div key={q.id} className="space-y-3">
                                                        <label className="block text-sm font-black text-slate-700">{q.label} {q.required && <span className="text-red-500">*</span>}</label>
                                                        {q.description && <p className="text-xs text-slate-400 -mt-2 italic">{q.description}</p>}

                                                        {q.type === 'text' && (
                                                            <input
                                                                type="text"
                                                                placeholder={q.placeholder || "回答を入力..."}
                                                                className="w-full px-4 py-3 rounded-xl border border-slate-200 focus:ring-4 focus:ring-indigo-100 focus:border-indigo-500 transition-all outline-none bg-slate-50/50"
                                                                value={answers[q.id] || ''}
                                                                onChange={(e) => handleInputChange(q.id, e.target.value)}
                                                            />
                                                        )}

                                                        {(q.type === 'select' || q.type === 'multi-select') && (
                                                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
                                                                {q.options?.map((opt, i) => {
                                                                    const isSelected = q.type === 'select' ? answers[q.id] === opt : (answers[q.id] || []).includes(opt);
                                                                    return (
                                                                        <button
                                                                            key={i}
                                                                            onClick={() => q.type === 'select' ? handleInputChange(q.id, opt) : handleMultiSelectChange(q.id, opt, !isSelected)}
                                                                            className={`text-left px-4 py-3 rounded-xl border text-sm transition-all flex items-center justify-between ${isSelected ? 'border-indigo-600 bg-indigo-50 text-indigo-700 font-bold' : 'border-slate-200 hover:bg-slate-50 text-slate-600'}`}
                                                                        >
                                                                            {opt}
                                                                            {isSelected && <IconCheck />}
                                                                        </button>
                                                                    );
                                                                })}
                                                            </div>
                                                        )}

                                                        {q.type === 'boolean' && (
                                                            <div className="flex gap-4">
                                                                {[true, false].map((val) => (
                                                                    <button
                                                                        key={val.toString()}
                                                                        onClick={() => handleInputChange(q.id, val)}
                                                                        className={`flex-1 py-3 rounded-xl border text-sm font-bold transition-all ${answers[q.id] === val ? 'border-indigo-600 bg-indigo-50 text-indigo-700' : 'border-slate-200 text-slate-600'}`}
                                                                    >
                                                                        {val ? 'はい' : 'いいえ'}
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                ))}
                                                <button
                                                    onClick={handleFinishAndCopy}
                                                    className="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-4 rounded-xl font-black text-lg shadow-lg transition-all active:scale-[0.98] flex items-center justify-center gap-2"
                                                >
                                                    回答を完了してYAMLを出力する
                                                </button>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="h-full flex flex-col items-center justify-center text-slate-300 gap-4 text-center">
                                            <IconTerminal />
                                            <p className="font-bold">DSLを入力してください（ルート: questions）<br /><span className="text-xs font-normal">AIにガイドラインを渡してDSLを作らせることができます</span></p>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* データ出力タブ */}
                            {activeTab === 'export' && (
                                <div className="flex-1 flex flex-col p-6 md:p-10 fade-in bg-white overflow-hidden text-slate-800">
                                    <div className="flex items-center justify-between mb-4 flex-shrink-0">
                                        <h3 className="text-lg font-black tracking-tight text-indigo-700">Answers Generated</h3>
                                        <button
                                            onClick={() => { copyToClipboard(yamlOutput); showToast('コピーしました'); }}
                                            className="px-3 py-1 bg-indigo-600 text-white rounded-md text-xs font-bold flex items-center gap-1 hover:bg-indigo-700 transition-colors"
                                        >
                                            <IconCopy /> 再コピー
                                        </button>
                                    </div>
                                    <pre className="flex-1 bg-slate-900 text-emerald-400 p-6 rounded-2xl font-mono text-sm overflow-auto border border-slate-800 shadow-inner leading-relaxed">
                                        {yamlOutput}
                                    </pre>
                                </div>
                            )}
                        </div>

                        {/* トースト通知 */}
                        {toast.visible && (
                            <div className="absolute bottom-6 left-1/2 -translate-x-1/2 slide-up pointer-events-none">
                                <div className="bg-slate-800 text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-3 border border-slate-700">
                                    <IconInfo />
                                    <span className="text-sm font-bold">{toast.message}</span>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>